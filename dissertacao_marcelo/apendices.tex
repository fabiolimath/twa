
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Revisão das Teorias Utilizadas
%% Copyright 2009 Marcelo de Oliveira Lima.
%% Este documento é distribuído nos termos da licença 
%% GNU General Public License v2.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\chapter{Algoritmos Genéticos}
\label{ga}

Os algoritmos genéticos (\textit{GAs} - \textit{Genetic Algorithms}) são mecanismos de pesquisa baseados no processo de seleção natural e na combinação
genética. Sua ideia
principal é fazer com que indivíduos com certas características especiais, isto é, aqueles com mais afinidade com a função de estudo, sobrevivam e se combinem.
Os
GAs utilizam processos de escolha e combinação randômicos, seguindo algumas regras probabilísticas. Isto se deve ao fato de poder rastrear com menos vínculos um
conjunto maior de indivíduos evitando cair em convergências a pontos de máximos e mínimos locais \cite{ga1,ga2}.

O GA foi primeiro proposto por Holland (1975). É um método de otimização que opera sobre uma população de indivíduos, que representam possíveis soluções do
problema. A cada um é associada uma aptidão ({\itshape fitness}) para a solução do problema em questão. As populações de indivíduos são criadas e submetidas a
operadores genéticos: de seleção, cruzamento ( {\itshape crossover}) e mutação. Com base no {\itshape fitness }de cada indivíduo, estes operadores geram um
processo de evolução natural dos mesmos. As possíveis respostas geradas para o problema são vistas como indivíduos que competirão entre si pela oportunidade de
se
reproduzirem. Os mais aptos têm maior chance de perpetuar parte de suas características, aumentando assim a probabilidade de se obter uma maior adaptação da
população em geral \cite{ga1}. Algumas vantagens dos GA's são seu alto grau de adaptabilidade e paralelismo.

Como exemplo, considere um problema do caixeiro viajante ou TSP, um dos problemas de roteamento mais tradicionais e conhecidos de programação
matemática \cite{tsp}. O TSP é descrito por um conjunto de $n$ cidades e uma matriz de distância entre elas, tendo o seguinte objetivo: o caixeiro viajante deve
sair, de uma cidade chamada origem, e visitar cada uma das $n$ cidades apenas uma única vez, retornando à cidade origem, percorrendo a menor distância possível,
ou seja, deve ser encontrada uma rota fechada (ciclo hamiltoniano \cite{cormen02}) de comprimento mínimo que passe exatamente uma única vez por cada cidade.
Na
Figura \ref{tsp} temos um exemplo de uma solução para um TSP de quatro cidades. Uma solução para um  TSP é uma combinação das $n$ cidades que compõem o
problema,
e cada permutação desta é outra solução.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.8]{figs/tsp.eps}
\end{center}
\caption{Exemplo de uma solução para um TSP de quatro cidades.}
\label{tsp}
\end{figure}

Considere um algoritmo genético para um TSP de 6 cidades, com população inicial que contenha as sequencias [123654] e [213645]. A partir de um processo de
seleção
que leva em consideração o melhor desempenho de um indivíduo ao cumprimento da função objetivo (no caso minimizar o percurso entre as cidades), grupos de
cromossomos par a par são escolhidos para reprodução. Num mecanismo de {\itshape crossover}, trocas de partes de seus genes são efetuadas e eventualmente
ocorrem
mutações possibilitando a variação numérica. Uma nova população com isso é gerada e o processo é reiniciado. Seleciona-se aleatoriamente um ponto de ruptura da
sequencia (ponto de {\itshape crossing}), por exemplo, posição 3 : [123.654] e [213.645]. Permutando as duas partes dos cromossomos pais, cria-se uma próxima
geração ({\itshape offspring}) de indivíduos : [123645] e [213654] que decodificados representam caminhos diferentes dos originais. Por sua vez se for efetuado
uma mutação na sequencia [123645], permutando-se seus  dois últimos alelos obtém-se [123654]. 

A codificação da informação em cromossomos é um ponto crucial durante o processo de modelagem do problema real, e junto com a função objetivo, liga o GA ao
problema a ser resolvido. Se a codificação for feita de forma inteligente, essa já incluirá as características do problema e permitirá que se evitem testes de
viabilidade de cada uma das soluções geradas. No exemplo, se utilizarmos a posição 4 como ponto de {\itshape crossing}, teríamos como resultado [123655] e
[213644] que não representa uma solução para o TSP, e eles deverão ser descartados (lhes será atribuído um {\itshape fitness }que os exclua do processo
evolutivo). Se a codificação não permitir esse tipo de anomalia, tais verificações serão desnecessárias, melhorando assim o desempenho do algoritmo.

O modelo de cromossomos mais utilizado é a representação binária, um vetor ou matriz de zeros e uns. Deste modo, uma codificação natural para uma topologia
virtual seria tomar a matriz de adjacências como cromossomo. Entretanto, o GA pode gerar qualquer matriz de zeros e uns de mesma ordem o que pode gerar
topologias
inviáveis. Na Tabela \ref{matriz-anel-6} vemos uma matriz de adjacências e sua respectiva topologia virtual na Figura \ref{anel-6}.

\begin{table}[!ht]
\begin{center}

\begin{tabular}{|c|c|c|c|c|c|}
\hline 0 & 1 & 0 & 0 & 0 & 0 \\
\hline 0 & 0 & 1 & 0 & 0 & 0 \\
\hline 0 & 0 & 0 & 1 & 0 & 0 \\
\hline 0 & 0 & 0 & 0 & 1 & 0 \\
\hline 0 & 0 & 0 & 0 & 0 & 1 \\
\hline 1 & 0 & 0 & 0 & 0 & 0 \\
\hline
\end{tabular}
\end{center}
\caption{Matriz de Adjacências de um anel}
\label{matriz-anel-6}
\end{table}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.6]{figs/anel-6.eps}
\caption{Anel de 6 nós}
\label{anel-6}
\end{figure}

Esta matriz poderia ser interpretada como um cromossomo binário $6x6$, mas um indivíduo que tivesse entradas não nulas na diagonal não poderia representar uma
topologia. Outro problema é a questão do grau lógico; as entradas não nulas do cromossomo, em cada linha e coluna, não podem exceder o grau lógico da rede. Além
de outras restrições que podem ser consideradas, como o tipo de topologia (por exemplo, anéis). Mas, por outro lado, não importa ao GA como se codifica ou
decodifica a informação dos parâmetros. Toda a informação relativa ao problema está contida na função objetivo do problema, que embute os módulos de codificação
e
decodificação dos parâmetros. Deste modo, os operadores genéticos devem ser implementados de forma a não gerarem soluções inviáveis, ou a função objetivo deverá
estar apta a lidar com elas.

\chapter{Implementação de Algoritmos Genéticos}
\label{galib}

Diversas ferramentas para o auxílio na implementação de um GA  encontram-se disponíveis atualmente. Destaca-se a biblioteca GAlib \footnote{{\tt
http://lancet.mit.edu/ga/}} \cite{wall}, da linguagem de programação C++, que foi escolhida para trabalhar os GAs neste trabalho, por possuir vários algoritmos
implementados, além de ter licença livre e código aberto. O que permite a utilização dos objetos prontos, ao mesmo tempo em que possibilita a livre
adaptação e complementação.

A GAlib é uma biblioteca multiplataforma (Unix, Linux, MacOS, Windows). Sua interface baseia-se em duas classes de objetos C++: o genoma ({\itshape genome}), e
o
GA ({\itshape genetic algorithm}). Cada objeto da classe {\itshape genome} é um indivíduo da população; uma solução para o problema. Já o objeto {\itshape
genetic
algorithm} define como a evolução será feita, utilizando uma função objetivo (definida pelo usuário) responsável pela decodificação do genoma e atribuição do
{\itshape fitness }aos indivíduos \cite{wall}.

Utilizando os operadores (implementados no {\itshape genome}) e as estratégias de seleção (implementados no {\itshape genetic algorithm}) são gerados novos
indivíduos.  Para um algoritmo genético simples, basta definir a representação (a maneira como uma solução será codificada em um genoma) a partir das classes de
genoma existentes, definir a função objetivo e escolher um algoritmo genético, dentre os oferecidos pela biblioteca, e talvez passar mais alguns parâmetros,
como
critérios de parada e tamanho das populações. Novos genomas e operadores podem ser implementados pelo usuário para modificar um GA ou elaborar seu próprio
algoritmo. Um GA contém as características gerais do algoritmo e dos operadores, a estratégia de evolução, os parâmetros de execução e o critério de parada,
todos
personalizáveis. 

A GAlib pode ser processada de maneira distribuída, evoluindo populações e/ou indivíduos paralelamente em  múltiplos CPUs. Os parâmetros  do algoritmo genético
podem ser configurados em arquivo, em linha de comando, e/ou no próprio código. São suportados algoritmos com sobreposição de população ({\itshape
Overlapping}),
nos quais se pode definir o número de indivíduos (ou uma porcentagem da população) a ser mantida a cada geração. A documentação da biblioteca inclui exemplos de
outros algoritmos genéticos derivados, tais como um algoritmo genético com sub populações e outros que usam aglomeração determinística ({\itshape deterministic
crowding}). Dentre os critérios internos de parada estão a convergência e o número de populações, que podem ser personalizados. 

Os cromossomos podem ser construídos de qualquer tipo de dados de C++. Pode-se usar os tipos internos à biblioteca ({\itshape bit-string, array, list, tree})
ou
criar um cromossomo baseado em seus próprios objetivos. Os tipos internos do cromossomo incluem {\itshape arrays }(arranjos), {\itshape list }(lista), {\itshape
tree} (árvore), 1D, 2D, e 3D {\itshape arrays}, 1D, 2D, e 3D {\itshape binary string}. As listas e as árvores podem conter todo tipo de objeto em seus nós, bem
como os arranjos em cada um de seus elementos. A biblioteca contem quatro tipos de genomas:  {\itshape GAListGenome, GATreeGenome, GAArrayGenome}, e {\itshape
GABinaryStringGenome}.  Estas classes são derivadas da classe básica GAGenome e de uma classe de estrutura de dados como indicado por seus nomes (por exemplo, o
{\itshape GAListGenome} é derivado das classes {\itshape GAList }e {\itshape GAGenome}).  Por exemplo, se estiver tentando otimizar uma função que dependa de 5
números reais, use então como seu genoma um arranjo de uma dimensão de números reais com 5 elementos.

Há muitos tipos diferentes de algoritmos genéticos.  A biblioteca GAlib inclui três tipos básicos:  {\itshape simple,  steady-state, e incremental}.  Estes
algoritmos diferem na maneira como criam indivíduos novos e substituem indivíduos velhos durante uma evolução. Esta biblioteca ainda fornece dois mecanismos
preliminares que estendem as potencialidades dos objetos internos.  Um recurso bastante utilizado é a definição de classes personalizadas com novas funções
membro.  Mas, se houver necessidade de fazer somente ajustes menores ao comportamento de uma classe GAlib, na maioria dos casos pode-se definir uma única função
e
dizer à classe existente para usá-la ao invés do {\itshape default}.


\chapter{Estimação de Parâmetros}

... Falta escrever.

